1. **python2和python3区别**
    - 统一了字符编码支持
    - 增加了一些语法：print、exec成为函数，添加了nonlocal、yiled from、async/await、yeild for、关键词和__annotations__、__context__、__traceback__、__qualname__等dunder方法；支持类型标注，f-string
    - 修改了一些语法：riase、map、filter、dict的items、keys、values返回迭代对象而不是列表，保存类属性定义顺序，保存关键字参数顺序
    - 去掉了一些语法：cmp,<>,xrange,不再有经典类
    - 增加了一些新的模块：concurrent.futures,venv,asyncio,unittest.mock，selectors,typing等
    - 修改了一些模块：主要是对模块添加函数、类、方法（）或者参数，例如threading.Barrier栅栏，functools.lru_cache（缓存执行结果，提高执行效率）
    - 模块改名字：相关的一些模块放在同一个包里面（httplib,BaseHTTPServer,CGIHTTPServer,SimpleHTTPServer,Cookie,cookielib都放在http里面，urllib、urllib2、urlparse、robotparse放进了urllib里面） Queue改成queue等
    - 去掉了一些模块或者函数：gopherlib、md5等过时的技术产物，有了新的替代物
    - 优化：重新实现了dict的实现减少20%-25%的内存使用，提升pickle序列化和反序列化的效率；collections.OrderedDict改用C实现os.scandir对glob模块中的glob()及iglob()进行优化，使得他们现在快了3-6倍
    - 其他：python2：3/2=1 python3:3/2=1.5; 构建过程、C的API、安全性等方面的修改
2. **HTTP GET、POST、PATCH、PUT**
    - GET 和 POST
        a、GET在浏览器回退时是无害的，而POST会再次提交请求
        b、GET产生的url地址可以被Bookmark，而POST的不可以
        c、GET会被浏览器主动cache，而POST不会，除非主动设置
        d、GET请求只进行url编码，而POST请求支持多种编码方式
        e、GET请求参数会被完整的保留在浏览器记录里面，而POST中的参数不会被保留
        f、GET请求在url中传送的参数长度是有限制的，而POST的参数并不在url中，所以没有长度限制，大多数浏览器url长度限制在2k
        g、GET比POST更不安全，因为GET的参数全部在url上
        h、GET请求参数在url上，POST的请求参数在Request Body中，服务器一般默认GET的RequestBody会忽略
        i、GET产生一个TCP包，POST产生两个TCP包（大多数浏览器，Firefox post只有一个包）
        j、GET获取资源，幂等的，安全的；POST创建资源，非幂等的，不安全
    - PUT 和 PATCH
        a、PATCH更新局部资源，PUT更新完整的资源
        b、PATCH是非幂等的，PUT是幂等的，两个都是不安全的
        c、PATCH请求中的实体保存的是修改资源的指令，该指令指导服务器来对资源做出修改；PUT请求中的实体是要替换旧资源的实体
3. **HTTP 状态码**
    - 2xx 成功
         - 200 OK：请求成功
         - 201 Createtd：请求已经成功，并因此创建了一个新资源，PUT和POST
         - 202 Accepted：请求已经接收到，但是没有响应，也没有结果
         - 204 No Content：服务器成功处理了请求，但是不需要返回任何实体内容，并且希望返回更新了的元信息
         - 205 Reset Content：服务器已经成功处理了请求，但是没有返回任何内容。与204响应不同，返回此状态码的响应要求请求者重置文档视图
         - 206 Partial Content：进行范围请求
    - 3xx
        - 301 Moved Permanently：请求的资源已经被永久的移动到别的位置，并且将来任何对此资源的引用都应该使用响应返回的若干个URI之一
        - 302 Found：请求的资源现在临时从不同的URI响应请求，由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的
        - 303 See Other：对当前的请求的响应可以在另一个URI上被找到，而且客户端应该采用GET的方式访问那个链接
        - 304 Not Modified：服务器允许访问资源，但是该文档内容并没有改变，304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。请求的时候一般结合If-Modified-Since头部使用
        - 307 Temporary Redirect：资源临时重定向，在重新发出原始请求时不允许更改请求方法
    - 4xx
        - 400 Bad Request：请求报文存在语法错误
        - 401 Unauthorized：登录凭证无效
        - 403 Forbidden：请求的资源的访问被服务器拒绝
        - 404 Not Found：请求资源在服务器上未找到
        - 408 Request Timeout：客户端请求超时
        - 409 Confict：请求的资源可能引起冲突
        - 410 Gone：请求资源在服务器已经不可用，并且没有任何已知的转发地址
        - 422 Unprocessable Entity：请求格式良好，但是由于语法错误无法遵循，（检查传参格式语义）
        - 429 Too Many Requests：给定时间内发送了太多的请求，DDOS攻击中可以使用到
    - 5xx
        - 500 Intertal Server Error：服务器端在执行请求时候发生了错误
        - 501 Not Implemented：请求超出服务器能力范围
        - 502 Bad Getway：错误的网关，无效网关
        - 503 Service Unavailable：服务不可用，服务器可能维护或者重启导致停机不可用
        - 504 Gateway Timeout：网关超时，服务器未能快速做出反应
        - 505 Http Version Not Supported：服务器不支持请求中的http版本
4. **HTTP和HTTPS HTTP2相比HTTP1.x优势**
    https是安全版的http
    - **https保证安全**：
        - 1、对称加密+非对称加密 客户端：将对称加密的秘钥使用非对称加密的公钥进行加密 服务端：使用私钥进行解密得到对称加密的秘钥，然后双方用对称加密进行通信
        - 2、安全的第三方颁布的证书（CA）：防止中间人攻击
        - 3、数字签名：方式数字证书被篡改，CA自带的HASH算法对证书内容生成一个摘要，再用CA的私钥加密生成数字签名

    HTTP2
    - 二进制分帧
    - 服务器推送
    - 头部压缩
    - 多路复用
5. **session和cookie**
    - 存储位置不同：cookie存储在浏览器上，session存储在服务器上
    - 隐私策略不同：cookie不是很安全，cookie欺骗，为了安全应当使用session
    - session保存在服务器，占用服务器资源，为了减轻服务器性能，应当使用cookie
    - 存储大小：单个cookie大小不超过4k，很多浏览器一个站点最多保存cookie20个
6. **CSRF：网站过分相信用户**
    - 验证HTTP Referer字段
    - 请求地址中添加token字段验证
    - 在http头中自定义属性并验证
7. **XSS：用户过分相信网站**
    - 危害：
        - 窃取网页浏览中的cookie的值
        - 劫持流量进行恶意跳转
    - 防范：
        - 过滤标签：<script> <img> <a>
        - 编码：<>进行编码，浏览器不会对该标签解释执行，也不影响显示效果
        - 限制：对一些可以预期的输入进行长度限制
8. **RPC**
    远端过程调用，分布式系统常见的一种通信方式，其调用协议通常包括传输协议和序列化协议，**传输协议**：grpc的http2协议，dubbo自定义报文的tcp协议 **序列化协议**：基于文本的xml，json，也有二进制编码的protobuf hessian等
    - 优势
        - 调用简单透明；参数和返回值简单明了；轻量，没有多余信息；便于管理，有注册中心
        - 跨语言，以及能够解耦服务
    
    - 核心组件
        - 用于暴露服务接口的RpcServer
        - 用于发现服务接口的RpcClient
        - 远程接口的代理实现RpcProxy
        - 负责协议编解码的RpcProtocol
        - 网络连接器
9. 并发与并行
    - 并发：是在同一个CPU上同时运行多个程序，并发性是对有限的物理资源强制执行多用户共享以提高效率；某个系统支持多个动作同时存在，这个系统就是并发系统
    - 并行：多个程序同一时刻在不同的CPU上执行，两个或者两个以上的事件在同一时刻发生；某个系统支持多个动作同时执行，这个系统就是并行系统
10. 同步和异步，阻塞和非阻塞
    - 同步和异步关注的是消息通信机制。所谓同步，就是发生一个调用，在没有得到结果之前，该调用就不返回，但是一旦调用返回，就得到返回值。换句话说就是调用者主动等待这个调用结果；异步则是相反的，调用发生之后，虽然调用直接返回了，但是调用者并不会立即得到结果，被调用者通过状态、通知告知调用者，或者通过回调函数处理这个调用
    - 阻塞和非阻塞关注的是程序在等待调用结果时候的状态。阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果会后才会返回；非阻塞调用指在不能立刻得到调用结果之前，该调用不会阻塞昂前线程
11. 进程、线程、协程
    1. 进程
        - 操作系统中CPU分配资源的基本单位
        - 进程是资源的容器，包含一个或者多个线程
        - 进程拥有一个完整的虚拟地址空间，不依赖于线程而多存在
        - 进程执行过程是线状的，尽管中间会中断或者暂停

    2. 线程
        - 操作系统中CPU独立运行和独立调度的基本单位
        - 同一进程下的线程共享资源，但是寄存器，栈等不共享
        - 线程是进程的一部分，没有自己的地址空间，于进程内的其他线程共享分配给该进程的资源
        - 线程执行时候一般要同步和互斥，因为共享进程资源

12. Redis分布式锁
    - 单机
        - SETNX(Key,ExpireTime)获取锁
        - 如果获取锁失败，通过GET(Key)返回的时间戳检查锁是否已经过期
        - GETSET(Key,ExpireTime)修改Value为NewExpireTime
        - 检查GETSET返回的旧值，如果等于GET返回的值，则认为获取锁成功
        注意：这个版本去掉了EXPIRE命令，改为通过Value时间戳值来判断过期

    - 集群
        - RedLock
            - 获取当前的时间戳
            - 按顺序依次向N个Redis节点执行获取锁操作
            - 计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第一步记录的时间
            - 如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间
            - 如果最终获取锁失败了，那么客户端应该立即向所有Redis节点发起释放锁的操作
            - 释放锁，对所有的Redis节点发起释放锁操作

13. 分布式事物
    CAP理论
    Consistency 一致性：同一个数据多个副本是否相同
    Availability 可用性：一定时间内系统返回一个明确的结果
    Partition tolerance 分区容错：将一个服务分布在多个系统中，从而保证某一个系统宕机，任然有其他系统提供相同的服务
    - 分布式事务协议
        - 两段提交协议
        假设的前提a：存在一个节点作为协调者，其他节点作为参与者，所有节点之间进行网络通信 b：所有节点预先写日志在可靠的存储设备上，节点损坏日志也不会丢失 c：节点不会永久性损坏，即使损坏后任然可以恢复
            - 第一阶段 投票阶段
                - 1、协调者向所有参与者节点询问是否可以执行提交操作，并开始等待参与者节点的响应
                - 2、参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志（每个参与者已经执行完成实务操作）
                - 3、各参与者节点响应协调者节点发起的询问。如果参与者节点事务操作成功，则返回“同意”消息，失败返回“中止”消息
            - 第二阶段 提交执行阶段
            当协调者节点从所有参与者节点获得的相应消息都为“同意”时：
                - 1、协调者节点向所有参与者节点发起“正式提交（commit）“的请求
                - 2、参与者节点正式完成操作，并释放在整个事务期间占用的资源
                - 3、参与者节点向协调者节点发送”完成“消息
                - 4、协调者节点收到所有参与者节点反馈的”完成“消息后，完成事务

                如果任意一个参与者节点返回”中止“消息，或者协调者第一阶段的轮询超时之前，无法获取所有参与者的响应消息时：
                - 1、协调者向所有参与者节点发送”回滚（rollback）“的请求
                - 2、参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源
                - 3、参与者节点向协调者节点发送”回滚完成“消息
                - 4、协调者节点受到所有参与者节点反馈的”回滚完成“消息后，取消事务
                    
                两段式提交的缺点：
                - 执行过程中，所有参与者节点都是事务阻塞型的。
                - 参与者发生故障，没有过多容错机制
                - 协调者发生故障，参与者会一直阻塞，需要额外的备机进行容错。
            
        - 三段提交协议
            - canCommit
            - preCommit
            - doCommit
    - 分布式事务解决方案
        - 全局事务（DTP模型）
        XA协议实现，XA协议指的是TM（事务管理器）和RM（资源管理器）之间的接口。目前主流的关系型数据库产品都实现了XA接口的。比较适合单体应用，性能较差。
        - 本地消息表，最大努力通知，定期校对
        将分布式事务拆分成本地事务进行处理
        - MQ事务消息
        - TCC 补偿机制
        - GTS 全局事务服务

14. Mysql存储引擎 MYISAM和Innodb的区别
    - MyISAM不支持事务，Innodb支持事务。Innodb实现了四个标准的隔离级别，ReadUncommitted、ReadCommitted、RepeatableRead、Serializable；通过间隙锁策略防止幻读出现，通过多版本并发控制（mvcc）支持高并发
    - MyISAM仅支持表锁，Innodb支持行锁
    - MyISAM允许没有主键的存在，Innodb在没有指定主键时候，会自动生成6个字节的ROWID列，以此作为主键，这个主键对用户不可见
    - MyISAM将数据和索引分开存储，索引.MYI文件，数据.MYD文件，Innodb的主键索引树的叶子节点保存的是主键和相应的行数据，其他索引树的叶子节点保存的是主键
    - MyISAM不支持外键，Innodb支持外键
    - MyISAM仅仅会缓存索引信息
13. 快速排序+不适用额外空间的快速排序
14. Mysql存储引擎MYISAM和Innodb的区别
15. Mysql Innodb 索引实现
16. Mysql Innodb 事物
17. Mysql 分表分库
18. Flask g、request、current_app的实现
19. RESTFful的理解